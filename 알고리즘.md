1. 시간복잡도

- 시간 복잡도를 이용하여 작성한 코드의 시간이 얼마나 걸릴지 예상한다.
- Big O Notation.
- 최악의 경우에 시간이 얼마나 걸릴지를 확인.
- 시간 복잡도 안에 가장 큰 입력 법위를 넣었을때 대략, 1억이 1초 정도로 계산하자.

```pseudocode
int sum = 0;
for(int i =1; i<=N; i++){
	sum+= i;
} 

int sum = 0; // 1
int i = 1; // 1
i++; // N
sum += i // N

2N+2


O(N)
```

```pseudocode
int sum = 0;
sum = N*(N+1)/2;

int sum = 0; // 1
N*(N+1)/2 //3
sum = N*(N+1)/2 //1

5

O(1)
```

```pseudocode
int sum = 0;

for(int i = 1 ; i<=N; i++){
	for(int j =1; j<=N; j++){
		if(i==j){
			sum+= j;
		}
	}
}

N*O(N) = O(N^2)
```

```pseudocode
O(1) -> 단순계산(a+b같은 연산, 배열에 접근하는 연산)
O(logN) -> N개를 절반으로 계속해서 나눔
O(N) : 1억 -> 1중 for문
O(NlogN) :5백만
O(N^2) :1만 -> 2중 for문
O(N^3) :500 -> 3중 for문
O(2^N) :20 = 2^20 = 1048576 -> 크기가 N인 집합의 부분집합
O(N!) :10, 10! = 3628800 -> 크기가 N인 순열
```

- Big O Notation에서 상수는 버린다.
- O(3N^2) = O(N^2)
- O(1/2 N^2) = O(N^2)
- O(5) = O(1)
- 두가지 항이 있을 때, 변수가 같으면 큰 것만 두고 버림.
  - O(N^2 +N) = O(N^2)
- 두가지 항이 있을때 변수가 다르면 버릴 수 없음.
  - O(N^2+M)

```pseudocode
scanf("%[^\n]\n",s);
//[]안의 것만 빼고(^), 입력을 받는다.
```



2. 자료구조

   2-1. 스택

- 한쪽 끝에서만 자료를 넣고 뺄 수 있는 자료구조.

- Last In Frist Out.

| 연산  | 설명                                           |
| ----- | ---------------------------------------------- |
| push  | 스택에 자료를 넣는 연산                        |
| pop   | 스택에 자료를 빼는 연산                        |
| peek  | 스택의 가장 위에 있는 자료를 보는연산          |
| empty | 스택이 비어있는지 확인하는 연산                |
| size  | 스택에 저장되어 있는 자료의 개수를 구하는 연산 |



​		2-2. 큐(Queue)

- 한쪽 끝에서만 자료를 넣고 다른 한쪽 끝에서만 뺄 수 있는 자료구조.
- First In First Out.

| 연산  | 설명                                            |
| ----- | ----------------------------------------------- |
| offer | 큐에 자료를 넣는 연산                           |
| poll  | 큐에 자료를 빼는 연산                           |
| front | 큐의 가장 앞에 있는 자료를 보는 연산(자바에는?) |
| back  | 큐의 가장 뒤에 있는 자료를 보는 연산(자바에는?) |
| empty | 큐가 비었는지 확인하는 연산                     |
| size  | 큐에 저장되어 있는 자료의 개수를 구하는 연산    |



​		2-3. 덱 (Deque)

- Double-ended queue.

- 양 끝에서만 자료를 넣고 양끝에서 뺄 수 있는 자료구조.

| 연산       | 설명                         |
| ---------- | ---------------------------- |
| offerFirst | 덱의 앞에 자료를 넣는 연산   |
| offerLast  | 덱의 끝에 자료를 넣는 연산   |
| pollFirst  | 덱의 앞에서 자료를 빼는 연산 |
| pollLast   | 덱의 끝에서 자료를 빼는 연산 |



3. 문자열

- 아스키코드.
- '0' -> 48 / 'A' -> 65 / 'a' -> 97
- 0은 아스키코드로는 NULL을 나타냄.



4. 다이나믹 프로그래밍

- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘.

- 두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.
  - Overlapping Subproblem : 겹치는 부분문제.
    - 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.
    - 문제를 작은 문제로 쪼갤 수 있다.
  - Optimal Substructure :  문제의 정답을 작의 문제의 정답에서 구할 수 있을 때.
    - 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면,
    - 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.

- 피보나치 수

```
F0 = 0;
F1 = 1;

FN = FN-1 + FN-2 (N>=2)

Overlapping Subproblem : 큰 문제와 작은 문제를 같은 방법으로 풀 수 있고, 문제를 작은 문제로 나눔.
Optimal Substructure :  문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.

문제 : N번째 피보나치 수를 구하는 문제
작은 문제 : N-1번째 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제

문제 : N-1번째 피보나치 수를 구하는 문제
작은 문제 : N-2번째 피보나치 수를 구하는 문제, N-3번째 피보나치 수를 구하는 문제

문제 : N-2번째 피보나치 수를 구하는 문제
작은 문제 : N-3번째 피보나치 수를 구하는 문제, N-4번째 피보나치 수를 구하는 문제
```

```
Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.

10번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
9번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
8번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
...
5번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
4번째 피보나치 수를 구하면서 구한 4번째 피보나치 수

4번째 피보나치 수는 항상 같다.
```

- 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.
- Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다.
- 따라서, 정답을 한 번 구했으면, 정답을 어딘가에 메모해놓는다. (Memoization)
- 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.

```java
int fibonacci(int n){
	if(n<=1){
		return n;
	}else {
		return fibonacci(n-1) + fibonacci(n-2);
	}
}
```

```java
int memo[100]; //n번재 피보나치 수
int fibonacci(int n){
	if(n<=1){
		return n;
	}else {
		if(memo[n]> 0){	//메모가 있으면 메모를 리턴
			return memo[n];
		}
		memo[n] = fibonacci(n-1) + fibonacci(n-2);	//메모를 씀.
		return memo[n];
	}
}
```

```java
int d[100];
int fibonacci(int n){
	d[0] = 0;
	d[1] = 1;
	for(int i=2; i<=n; i++){
		d[i] = d[i-1] + d[i-2];
	}
	return d[n];
}
```

- 문제를 푸는 방법은 Top-down(큰 문제를 점점 작게 만들어 나가면서 푸는 방식), Bottom-up(작은 문제부터 풀어나가는 방식) 방식이 있다. 

- Top-down (재귀)

  - 1. 문제를 풀어야한다.
       - fibonacci(n)

    2. 문제를 작은 문제로 나눈다.
       - fibonacci(n-1)과 fibonacci(n-2)로 문제를 나눈다.
    3. 작은 문제를 푼다.
       - fibonacci(n-1)과 fibonacci(n-2)를 호출해 문제를 푼다.
    4.  작은 문제를 풀었으니, 이제 문제를 푼다
       - fibonacci(n-1)의 값과 fibonacci(n-2)의 값을 더해서 문제를 푼다.

  - 탑 다운은 보통 재귀함수로 풀 수있다.

  - 시간 복잡도 = 채워야하는 칸의 수(메모 배열) * 한 칸을 채우는 복잡도 

- Bottom-up (반복문)

  - 1. 물제를 크기가 작은 문제부터 차례대로 푼다.
       - for(int i=2; i<=n; i++)
    2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점푼다.
       - for(int i=2; i<=n; **i++**)
    3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.
       - d[i] = d[i-1] + d[i-2];
    4. 그러다보면, 언젠간 풀어야 하는 문제를 풀 수 있다.
       - d[n]

- 문제 풀이 전략

  - memo[i], d[i], dp[i]에 무엇이 들어가야하는지를 정한다.

  - 문제에서 구하려고 하는 답을 문장으로 나타낸다. N번째 피보나치 수
  - 그 문장에 나와있는 변수의 개수만큼 메모하는 배열을 만든다.
  - Top-down인 경우에는 재귀 호출의 인자의 개수
  - 문제를 작은 문제로 나누고,  수식을 이용해서 문제를 표현해야 한다.